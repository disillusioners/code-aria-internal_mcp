
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mcp-lang-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/code-aria/internal-mcp/cmd/mcp-lang-go/lint.go (55.2%)</option>
				
				<option value="file1">github.com/code-aria/internal-mcp/cmd/mcp-lang-go/main.go (0.0%)</option>
				
				<option value="file2">github.com/code-aria/internal-mcp/cmd/mcp-lang-go/mcp.go (88.9%)</option>
				
				<option value="file3">github.com/code-aria/internal-mcp/cmd/mcp-lang-go/testutils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
)

// toolLint executes golangci-lint and returns structured results
func toolLint(args map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Get target (file, directory, or "." for entire repo)
        target := "."
        if t, ok := args["target"].(string); ok &amp;&amp; t != "" </span><span class="cov8" title="1">{
                target = t
        }</span>

        // Get format (json or text)
        <span class="cov8" title="1">format := "json"
        if f, ok := args["format"].(string); ok &amp;&amp; f != "" </span><span class="cov0" title="0">{
                format = f
        }</span>

        // Get config file path
        <span class="cov8" title="1">configPath := ""
        if c, ok := args["config"].(string); ok &amp;&amp; c != "" </span><span class="cov0" title="0">{
                configPath = c
        }</span>

        <span class="cov8" title="1">repoPath := os.Getenv("REPO_PATH")
        if repoPath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("REPO_PATH environment variable not set")
        }</span>

        // Resolve target path
        <span class="cov8" title="1">var targetPath string
        if target == "." </span><span class="cov8" title="1">{
                targetPath = repoPath
        }</span> else<span class="cov8" title="1"> if filepath.IsAbs(target) </span><span class="cov8" title="1">{
                targetPath = target
        }</span> else<span class="cov8" title="1"> {
                targetPath = filepath.Join(repoPath, target)
        }</span>

        // Check if golangci-lint is available
        <span class="cov8" title="1">if _, err := exec.LookPath("golangci-lint"); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("golangci-lint is not installed or not in PATH. Please install it from https://golangci-lint.run/")
        }</span>

        // Build command
        // Use line-number format for easier parsing (more reliable than default)
        <span class="cov0" title="0">cmd := exec.Command("golangci-lint", "run", "--out-format", "line-number")
        
        // Add config file if specified or if default exists
        if configPath != "" </span><span class="cov0" title="0">{
                if !filepath.IsAbs(configPath) </span><span class="cov0" title="0">{
                        configPath = filepath.Join(repoPath, configPath)
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                        cmd.Args = append(cmd.Args, "--config", configPath)
                }</span>
        } else<span class="cov0" title="0"> {
                // Check for default config file
                defaultConfig := filepath.Join(repoPath, ".golangci.yml")
                if _, err := os.Stat(defaultConfig); err == nil </span><span class="cov0" title="0">{
                        cmd.Args = append(cmd.Args, "--config", defaultConfig)
                }</span>
                // Also check for .golangci.yaml (alternative extension)
                <span class="cov0" title="0">if _, err := os.Stat(filepath.Join(repoPath, ".golangci.yaml")); err == nil </span><span class="cov0" title="0">{
                        cmd.Args = append(cmd.Args, "--config", filepath.Join(repoPath, ".golangci.yaml"))
                }</span>
        }

        // Add target path
        <span class="cov0" title="0">cmd.Args = append(cmd.Args, targetPath)

        // Set working directory
        cmd.Dir = repoPath

        // Capture output
        var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Execute command
        err := cmd.Run()
        output := stdout.String()
        errOutput := stderr.String()

        // Parse output
        result := LintResult{
                Target:      target,
                TotalIssues: 0,
                Issues:      []LintIssue{},
                Success:     err == nil &amp;&amp; len(output) == 0,
        }

        if err != nil </span><span class="cov0" title="0">{
                // Check if it's just lint errors (exit code 1) or a real error
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        if exitError.ExitCode() == 1 </span><span class="cov0" title="0">{
                                // Exit code 1 means linting found issues, which is expected
                                result.Success = false
                        }</span> else<span class="cov0" title="0"> {
                                // Other exit codes indicate real errors
                                result.Error = fmt.Sprintf("golangci-lint execution failed: %s", errOutput)
                                return result, nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        result.Error = fmt.Sprintf("failed to execute golangci-lint: %v", err)
                        return result, nil
                }</span>
        }

        // Parse lint output
        <span class="cov0" title="0">issues := parseLintOutput(output)
        result.Issues = issues
        result.TotalIssues = len(issues)

        // If format is text, return as string
        if format == "text" </span><span class="cov0" title="0">{
                if result.Error != "" </span><span class="cov0" title="0">{
                        return result.Error, nil
                }</span>
                <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                        return output, nil
                }</span>
                <span class="cov0" title="0">return "No linting issues found", nil</span>
        }

        // Return structured JSON result
        <span class="cov0" title="0">return result, nil</span>
}

// parseLintOutput parses golangci-lint output into structured issues
func parseLintOutput(output string) []LintIssue <span class="cov8" title="1">{
        if len(strings.TrimSpace(output)) == 0 </span><span class="cov8" title="1">{
                return []LintIssue{}
        }</span>

        <span class="cov8" title="1">var issues []LintIssue
        lines := strings.Split(output, "\n")

        // golangci-lint line-number format:
        // file.go:line:column: message (linter)
        // file.go:line: message (linter)  (when column is not available)
        
        // Regex to match lint output in line-number format
        // Format: file:line:column: message (linter)
        // or: file:line: message (linter)
        re := regexp.MustCompile(`^(\s*)([^:]+):(\d+)(?::(\d+))?:\s*(.+?)\s*\(([^)]+)\)$`)

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">matches := re.FindStringSubmatch(line)
                if len(matches) &lt; 6 </span><span class="cov8" title="1">{
                        // Try alternative format without column
                        altRe := regexp.MustCompile(`^(\s*)([^:]+):(\d+):\s*(.+?)\s*\(([^)]+)\)$`)
                        altMatches := altRe.FindStringSubmatch(line)
                        if len(altMatches) &gt;= 6 </span><span class="cov0" title="0">{
                                file := altMatches[2]
                                lineNum, _ := strconv.Atoi(altMatches[3])
                                message := altMatches[4]
                                linter := altMatches[5]

                                // Determine severity from message or linter
                                severity := determineSeverity(message, linter)

                                issues = append(issues, LintIssue{
                                        File:     file,
                                        Line:     lineNum,
                                        Severity: severity,
                                        Linter:   linter,
                                        Message:  message,
                                })
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">file := matches[2]
                lineNum, _ := strconv.Atoi(matches[3])
                column := 0
                if matches[4] != "" </span><span class="cov8" title="1">{
                        column, _ = strconv.Atoi(matches[4])
                }</span>
                <span class="cov8" title="1">message := matches[5]
                linter := matches[6]

                // Determine severity from message or linter
                severity := determineSeverity(message, linter)

                issue := LintIssue{
                        File:     file,
                        Line:     lineNum,
                        Severity: severity,
                        Linter:   linter,
                        Message:  message,
                }

                if column &gt; 0 </span><span class="cov8" title="1">{
                        issue.Column = column
                }</span>

                <span class="cov8" title="1">issues = append(issues, issue)</span>
        }

        <span class="cov8" title="1">return issues</span>
}

// determineSeverity determines the severity of a lint issue
func determineSeverity(message, linter string) string <span class="cov8" title="1">{
        messageLower := strings.ToLower(message)
        
        // Check for explicit severity indicators
        if strings.Contains(messageLower, "error") || strings.Contains(messageLower, "fatal") </span><span class="cov8" title="1">{
                return "error"
        }</span>
        <span class="cov8" title="1">if strings.Contains(messageLower, "warning") || strings.Contains(messageLower, "warn") </span><span class="cov8" title="1">{
                return "warning"
        }</span>
        <span class="cov8" title="1">if strings.Contains(messageLower, "info") || strings.Contains(messageLower, "hint") </span><span class="cov8" title="1">{
                return "info"
        }</span>

        // Check linter name for severity hints
        <span class="cov8" title="1">linterLower := strings.ToLower(linter)
        if strings.Contains(linterLower, "err") || strings.Contains(linterLower, "fatal") </span><span class="cov8" title="1">{
                return "error"
        }</span>
        <span class="cov8" title="1">if strings.Contains(linterLower, "warn") </span><span class="cov8" title="1">{
                return "warning"
        }</span>

        // Default to warning for unknown cases
        <span class="cov8" title="1">return "warning"</span>
}


</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)
        encoder := json.NewEncoder(os.Stdout)

        // Initialize handshake
        if err := handleInitialize(scanner, encoder); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Initialize failed: %v\n", err)
                os.Exit(1)
        }</span>

        // Handle requests
        <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var msg MCPMessage
                if err := json.Unmarshal(line, &amp;msg); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if msg.Method != "" </span><span class="cov0" title="0">{
                        handleRequest(&amp;msg, encoder)
                }</span>
        }
}


</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "fmt"
)

// handleInitialize processes the MCP initialize request
func handleInitialize(scanner *bufio.Scanner, encoder *json.Encoder) error <span class="cov8" title="1">{
        if !scanner.Scan() </span><span class="cov8" title="1">{
                return fmt.Errorf("no initialize request")
        }</span>

        <span class="cov8" title="1">var initReq MCPMessage
        if err := json.Unmarshal(scanner.Bytes(), &amp;initReq); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse initialize: %w", err)
        }</span>

        <span class="cov8" title="1">response := MCPMessage{
                JSONRPC: "2.0",
                ID:      initReq.ID,
                Result: InitializeResponse{
                        ProtocolVersion: "2024-11-05",
                        Capabilities: map[string]interface{}{
                                "tools": map[string]interface{}{},
                        },
                        ServerInfo: ServerInfo{
                                Name:    "mcp-lang-go",
                                Version: "1.0.0",
                        },
                },
        }

        if err := encoder.Encode(response); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialize response: %w", err)
        }</span>

        <span class="cov8" title="1">if !scanner.Scan() </span><span class="cov8" title="1">{
                return fmt.Errorf("no initialized notification")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// handleRequest routes MCP requests to appropriate handlers
func handleRequest(msg *MCPMessage, encoder *json.Encoder) <span class="cov8" title="1">{
        switch msg.Method </span>{
        case "tools/list":<span class="cov8" title="1">
                handleToolsList(msg, encoder)</span>
        case "tools/call":<span class="cov0" title="0">
                handleToolCall(msg, encoder)</span>
        default:<span class="cov8" title="1">
                sendError(encoder, msg.ID, -32601, fmt.Sprintf("Unknown method: %s", msg.Method), nil)</span>
        }
}

// handleToolsList returns the list of available tools
func handleToolsList(msg *MCPMessage, encoder *json.Encoder) <span class="cov8" title="1">{
        tools := []Tool{
                {
                        Name:        "apply_operations",
                        Description: "Execute multiple Go language operations in a single batch call",
                        InputSchema: map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "operations": map[string]interface{}{
                                                "type":        "array",
                                                "description": "List of operations to execute",
                                                "items": map[string]interface{}{
                                                        "type":        "object",
                                                        "description": "Operation object with 'type' field and operation-specific parameters",
                                                        "properties": map[string]interface{}{
                                                                "type": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Operation type: lint",
                                                                },
                                                                "target": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "File path, directory path, or '.' for entire repository (optional, defaults to '.')",
                                                                },
                                                                "format": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Output format: 'json' or 'text' (optional, defaults to 'json')",
                                                                        "enum":        []string{"json", "text"},
                                                                },
                                                                "config": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Path to golangci-lint config file (optional, defaults to .golangci.yml if exists)",
                                                                },
                                                        },
                                                },
                                        },
                                },
                                "required": []string{"operations"},
                        },
                },
        }

        response := MCPMessage{
                JSONRPC: "2.0",
                ID:      msg.ID,
                Result: ToolsListResponse{
                        Tools: tools,
                },
        }

        encoder.Encode(response)
}</span>

// handleToolCall processes tool call requests
func handleToolCall(msg *MCPMessage, encoder *json.Encoder) <span class="cov8" title="1">{
        var req ToolsCallRequest
        reqJSON, err := json.Marshal(msg.Params)
        if err != nil </span><span class="cov8" title="1">{
                sendError(encoder, msg.ID, -32602, fmt.Sprintf("failed to marshal params: %v", err), nil)
                return
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(reqJSON, &amp;req); err != nil </span><span class="cov0" title="0">{
                sendError(encoder, msg.ID, -32602, fmt.Sprintf("failed to unmarshal params: %v", err), nil)
                return
        }</span>

        <span class="cov8" title="1">if req.Name == "apply_operations" </span><span class="cov8" title="1">{
                handleBatchOperations(msg, encoder, req.Arguments)
                return
        }</span>

        // Individual tool calls are no longer exposed, but kept for internal use
        <span class="cov8" title="1">sendError(encoder, msg.ID, -32601, fmt.Sprintf("Unknown tool: %s. Use apply_operations for batch operations", req.Name), nil)</span>
}

// handleBatchOperations processes a batch of operations
func handleBatchOperations(msg *MCPMessage, encoder *json.Encoder, args map[string]interface{}) <span class="cov8" title="1">{
        operations, ok := args["operations"].([]interface{})
        if !ok </span><span class="cov8" title="1">{
                sendError(encoder, msg.ID, -32602, "operations array is required", nil)
                return
        }</span>

        <span class="cov8" title="1">if len(operations) == 0 </span><span class="cov8" title="1">{
                sendError(encoder, msg.ID, -32602, "operations array cannot be empty", nil)
                return
        }</span>

        <span class="cov8" title="1">var results []map[string]interface{}

        for _, op := range operations </span><span class="cov8" title="1">{
                opMap, ok := op.(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        results = append(results, map[string]interface{}{
                                "operation": "unknown",
                                "params":    map[string]interface{}{},
                                "status":    "Error",
                                "message":   "Invalid operation format",
                        })
                        continue</span>
                }

                <span class="cov8" title="1">opType, ok := opMap["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        results = append(results, map[string]interface{}{
                                "operation": "unknown",
                                "params":    map[string]interface{}{},
                                "status":    "Error",
                                "message":   "Operation type is required",
                        })
                        continue</span>
                }

                // Extract operation-specific arguments as params
                <span class="cov8" title="1">params := make(map[string]interface{})
                for k, v := range opMap </span><span class="cov8" title="1">{
                        if k != "type" </span><span class="cov8" title="1">{
                                params[k] = v
                        }</span>
                }

                // Execute operation based on type
                <span class="cov8" title="1">var result interface{}
                var err error

                switch opType </span>{
                case "lint":<span class="cov8" title="1">
                        result, err = toolLint(params)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("unknown operation type: %s", opType)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        results = append(results, map[string]interface{}{
                                "operation": opType,
                                "params":    params,
                                "status":    "Error",
                                "message":   err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        results = append(results, map[string]interface{}{
                                "operation": opType,
                                "params":    params,
                                "status":    "Success",
                                "result":    result,
                        })
                }</span>
        }

        // Return results in format expected by client: {"results": [...]}
        <span class="cov8" title="1">response := MCPMessage{
                JSONRPC: "2.0",
                ID:      msg.ID,
                Result: map[string]interface{}{
                        "results": results,
                },
        }

        encoder.Encode(response)</span>
}

// sendError sends an error response
func sendError(encoder *json.Encoder, id interface{}, code int, message string, data interface{}) <span class="cov8" title="1">{
        response := MCPMessage{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;MCPError{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }
        encoder.Encode(response)
}</span>


</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "io"
        "os"
        "strings"
        "testing"
        "time"
)

// MockCommand implements a mock for exec.Command
type MockCommand struct {
        Cmd    string
        Args   []string
        Dir    string
        Output string
        Err    error
}

// TestTransport provides a transport layer for testing MCP communication
type TestTransport struct {
        Input  io.Reader
        Output io.Writer
}

// NewTestTransport creates a new test transport
func NewTestTransport(input string) *TestTransport <span class="cov0" title="0">{
        return &amp;TestTransport{
                Input:  strings.NewReader(input),
                Output: &amp;strings.Builder{},
        }
}</span>

// SendMessage sends a message through the transport
func (t *TestTransport) SendMessage(msg *MCPMessage) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(t.Output)
        return encoder.Encode(msg)
}</span>

// ReceiveMessage receives a message from the transport
func (t *TestTransport) ReceiveMessage() (*MCPMessage, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(t.Input)
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil, io.EOF
        }</span>

        <span class="cov0" title="0">var msg MCPMessage
        err := json.Unmarshal(scanner.Bytes(), &amp;msg)
        return &amp;msg, err</span>
}

// MockEnvironment provides a way to mock environment variables for testing
type MockEnvironment struct {
        values map[string]string
}

// NewMockEnvironment creates a new mock environment
func NewMockEnvironment() *MockEnvironment <span class="cov0" title="0">{
        return &amp;MockEnvironment{
                values: make(map[string]string),
        }
}</span>

// Set sets an environment variable
func (m *MockEnvironment) Set(key, value string) <span class="cov0" title="0">{
        m.values[key] = value
}</span>

// Get gets an environment variable
func (m *MockEnvironment) Get(key string) string <span class="cov0" title="0">{
        return m.values[key]
}</span>

// Apply applies the mock environment
func (m *MockEnvironment) Apply() <span class="cov0" title="0">{
        for key, value := range m.values </span><span class="cov0" title="0">{
                os.Setenv(key, value)
        }</span>
}

// Restore restores the original environment
func (m *MockEnvironment) Restore(original map[string]string) <span class="cov0" title="0">{
        // Clear current values
        for key := range m.values </span><span class="cov0" title="0">{
                os.Unsetenv(key)
        }</span>
        // Restore original values
        <span class="cov0" title="0">for key, value := range original </span><span class="cov0" title="0">{
                os.Setenv(key, value)
        }</span>
}

// CaptureEnvironment captures the current environment state
func CaptureEnvironment() map[string]string <span class="cov0" title="0">{
        env := make(map[string]string)
        for _, e := range os.Environ() </span><span class="cov0" title="0">{
                pair := strings.SplitN(e, "=", 2)
                if len(pair) == 2 </span><span class="cov0" title="0">{
                        env[pair[0]] = pair[1]
                }</span>
        }
        <span class="cov0" title="0">return env</span>
}

// TestMCPClient simulates an MCP client for testing
type TestMCPClient struct {
        transport *TestTransport
        id        int
}

// NewTestMCPClient creates a new test MCP client
func NewTestMCPClient(input string) *TestMCPClient <span class="cov0" title="0">{
        return &amp;TestMCPClient{
                transport: NewTestTransport(input),
                id:        1,
        }
}</span>

// Initialize performs the MCP initialization handshake
func (c *TestMCPClient) Initialize(t *testing.T) error <span class="cov0" title="0">{
        initReq := MCPMessage{
                JSONRPC: "2.0",
                ID:      c.nextID(),
                Method:  "initialize",
                Params: json.RawMessage(`{
                        "protocolVersion": "2024-11-05",
                        "capabilities": {},
                        "clientInfo": {"name": "test-client", "version": "1.0.0"}
                }`),
        }

        if err := c.transport.SendMessage(&amp;initReq); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Send initialized notification
        <span class="cov0" title="0">initNotif := MCPMessage{
                JSONRPC: "2.0",
                Method:  "initialized",
        }

        return c.transport.SendMessage(&amp;initNotif)</span>
}

// ListTools requests the list of available tools
func (c *TestMCPClient) ListTools(t *testing.T) (*MCPMessage, error) <span class="cov0" title="0">{
        req := MCPMessage{
                JSONRPC: "2.0",
                ID:      c.nextID(),
                Method:  "tools/list",
        }

        if err := c.transport.SendMessage(&amp;req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c.receiveMessage()</span>
}

// CallTool calls a specific tool
func (c *TestMCPClient) CallTool(t *testing.T, name string, args map[string]interface{}) (*MCPMessage, error) <span class="cov0" title="0">{
        params := map[string]interface{}{
                "name":      name,
                "arguments": args,
        }

        paramsBytes, err := json.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req := MCPMessage{
                JSONRPC: "2.0",
                ID:      c.nextID(),
                Method:  "tools/call",
                Params:  json.RawMessage(paramsBytes),
        }

        if err := c.transport.SendMessage(&amp;req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c.receiveMessage()</span>
}

// receiveMessage receives a message from the transport
func (c *TestMCPClient) receiveMessage() (*MCPMessage, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(c.transport.Input.(*strings.Reader))
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil, io.EOF
        }</span>

        <span class="cov0" title="0">var msg MCPMessage
        err := json.Unmarshal(scanner.Bytes(), &amp;msg)
        return &amp;msg, err</span>
}

// nextID returns the next message ID
func (c *TestMCPClient) nextID() int <span class="cov0" title="0">{
        id := c.id
        c.id++
        return id
}</span>

// GetOutput returns the output from the transport
func (c *TestMCPClient) GetOutput() string <span class="cov0" title="0">{
        if builder, ok := c.transport.Output.(*strings.Builder); ok </span><span class="cov0" title="0">{
                return builder.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// TestTimeout provides timeout functionality for tests
type TestTimeout struct {
        duration time.Duration
}

// NewTestTimeout creates a new test timeout
func NewTestTimeout(d time.Duration) *TestTimeout <span class="cov0" title="0">{
        return &amp;TestTimeout{duration: d}
}</span>

// Run runs a function with a timeout
func (tt *TestTimeout) Run(t *testing.T, testFunc func()) <span class="cov0" title="0">{
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                defer close(done)
                testFunc()
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0"></span>
                // Test completed
        case &lt;-time.After(tt.duration):<span class="cov0" title="0">
                t.Fatal("Test timed out")</span>
        }
}

// AssertNoError asserts that an error is nil
func AssertNoError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Unexpected error: %v", err)
        }</span>
}

// AssertError asserts that an error is not nil
func AssertError(t *testing.T, err error, expectedMsg string) <span class="cov0" title="0">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("Expected error but got nil")
        }</span>
        <span class="cov0" title="0">if expectedMsg != "" &amp;&amp; !strings.Contains(err.Error(), expectedMsg) </span><span class="cov0" title="0">{
                t.Fatalf("Expected error containing '%s', got '%s'", expectedMsg, err.Error())
        }</span>
}

// AssertEqual asserts that two values are equal
func AssertEqual[T comparable](t *testing.T, expected, actual T) <span class="cov0" title="0">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                t.Fatalf("Expected %v, got %v", expected, actual)
        }</span>
}

// AssertContains asserts that a string contains a substring
func AssertContains(t *testing.T, s, substr string) <span class="cov0" title="0">{
        t.Helper()
        if !strings.Contains(s, substr) </span><span class="cov0" title="0">{
                t.Fatalf("Expected '%s' to contain '%s'", s, substr)
        }</span>
}

// CreateTestFile creates a test file with the given content
func CreateTestFile(t *testing.T, dir, filename, content string) string <span class="cov0" title="0">{
        t.Helper()
        path := dir + "/" + filename
        if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test file: %v", err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// CreateTempDir creates a temporary directory for testing
func CreateTempDir(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()
        dir, err := os.MkdirTemp("", "mcp-lang-go-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp dir: %v", err)
        }</span>
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(dir)
        }</span>)
        <span class="cov0" title="0">return dir</span>
}

// WaitForCondition waits for a condition to be true or times out
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, message string) <span class="cov0" title="0">{
        t.Helper()
        start := time.Now()
        for time.Since(start) &lt; timeout </span><span class="cov0" title="0">{
                if condition() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov0" title="0">t.Fatalf("Condition not met within timeout: %s", message)</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
